:PROPERTIES:
:ID:       2CC161DF-B833-48D9-BF06-55AC72CEA0C9
:ROAM_REFS: https://www.gnu.org/software/emacs/manual/elisp.html
:END:
#+title: elisp
#+tags: number(n)
#+category: elisp

* Introduction
[[id:B71794A2-7543-43A5-B6FC-66B9F5CD2EB3][Emacs]] is mostly written in elisp, and this language is used to configure the editor and to programatically call editing commands.
** Conventions
*** Lisp Reader and Printer
The 'Lisp reader' denotes any Lisp routine that converts textual representations of Lisp objects into actual Lisp objects, and vice versa for the Lisp printer.
*** nil and t
~nil~ is a symbol with the name 'nil', logical false, and the empty list. As a variable, its value is always ~nil~. The Lisp reader accepts either '()' or 'nil'. The former emphasizes an empty list, while the latter emphasizes logical false. It is a good convention for writing code.

Like ~nil~, ~t~ evaluates to itself (i.e., its value as a variable is ~t~). They can be unquoted when used as constants in a program.
*** Evaluation, Expansion, and Identity Notation
The character used in this manual to indicate evaluation is '⇒'. The "form" or expression is on the left, and the Lisp object the form evaluates to is on the right.

#+begin_src emacs-lisp
  (car '(1 2)) ; ⇒ 1
#+end_src

Macro calls are forms that expand to a new form. Expansions are indicated by '→'.

Identity between forms that produce identical results is indiciated by '≡'.
*** Printing Notation
Evaluation is often accompanied by printed text (e.g., in the echo area). Printed text is indicated by '-|'.

#+begin_src emacs-lisp
  (progn (prin1 'foo) (princ "\n") (prin1 'bar))
  ;;     -| foo
  ;;     -| bar
  ;;     ⇒ bar
#+end_src
*** Error Messages
Errors are indicated by 'error→'
*** Buffer Text Notation
In examples of buffer text, an asterisk indicates the location of point.

NOTE: Asterisk is a formatting character in org-mode and may need to be escaped here.
*** Format of Descriptions
Functions, variables, macros, commands, user options, and special forms are described with a uniform format. The category (e.g., function) begins the line, followed by a colon, followed by the name of the item and its args if any.

Note that this summary of the manual omits a preceding category. Moreover, objects are given their own heading, followed by a description either to supplement the built-in description or because writing forces me to read the descriptions.

Below the syntax is a description and sometimes examples.

[[info:elisp#A Sample Function Description][Example function and special form descriptions]].
**** Functions
Arguments are italicized.

'&optional' indicates optional function arguments.

'&rest' indicates a variable number of trailing arguments. The single argument name following '&rest' has as its value a list of all remaining arguments passed to the function.

Any argument whose name contains the name of a type (e.g,. /integer1/) is expected to be of that type, and /object/ may be of any type. Plurals (e.g., /integers/) often indicate a list of objects of that type. Function documentation should otherwise describe the type of an argument.

Commands, macros, and special forms have the same basic format as functions.
***** Marco & Special Form Arguments
Macros and special forms use a more complex notation for optional and repeated arguments, because they can further parse the argument list. Brackets are used to indicate an '/[optional-arg]/', and dots to indicate '/repeated args.../'. Parentheses may be used to indicate a required list structure for groups of arguments.
**** Variables
Variables are names that are bound to an object, or value. User options are a special type of variable. The description format is self-explanatory, like that of user options.
** Version Information                                           :version:
*** emacs-version /&optional here/
*** emacs-build-time
Indicates the time at which Emacs was built using the style of ~current-time~.
*** emacs-version
*** emacs-major-version
*** emacs-minor-version
*** emacs-build-number
*** emacs-respository-version
*** emacs-repository-branch
* Lisp Data Types
This chapter describes the purpose, printed representation, and read syntax of the standard Lisp types.
*** Primitive Types
Lisp objects may have multiple types, so there is no way to query the sole type of an object, unless we are talking about primitive types. Each object belongs to a single primitive type:

1. integer
2. float
3. cons
4. symbol
5. string
6. vector
7. hash-table
8. subr
9. byte-code function
10. record
11. Editing Types, such as /buffer/
*** Printed Representation and Read Syntax
The printed representation of an object is the output of ~prin1~; the read syntax is the input accepted by ~read~.

In most cases, the print and read syntax of an object are identical. Some objects have no read syntax, since it does not make sense to enter them as constants into the program. These objects are printed in hash notation (i.e., ~#<...>~). Many objects have more than one syntax.

In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object's read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.

When you evaluate an expression interactively, the Lisp interpreter first reads the textual representation of it, producing a Lisp object, and then evaluates that object. Evaluation and reading are separate activities.

See [[info:elisp#Evaluation][Evaluation]] and [[info:elisp#Input Functions][Input Functions]].
**** Examples
***** Example 1
Most objects are self-evaluating. E.g., the read form "161" is read as the number 161. This number is self-evaluating.

In contrast, the read form 'abc' is read as the Lisp symbol named 'abc'. It evaluates to the value of its variable, but since the variable is void, an error is generated.
***** Example 2
A second example involves functions. ~(+ 1 (+ 1 3))~ is read as a list object. Each function call is evaluated, and the order of evaluation for the nested list is inside-out. (This order is not universal for lists, see below.)

In contrast, the special form ~setq~ avoids evaluating its first argument. It evaluates its second argument and assigns it to the unquoted first argument that names a symbol. Special forms do not follow the normal rules for functions that all arguments are evaluated.
***** Example 3
A [[https://www.heinrichhartmann.com/archive/problem-lisp.html][third example]] serves as a warning against assuming that the order of evaluation is always inside-out, as in the earlier function example.
*** Special Read Syntax
Lisp represents many special objects and constructs via special notation.
**** #<...>
Indicates objects without read syntax. '...' indicates a descriptive string, typically the object type followed by its name.
**** ##
Printed representation of an interned symbol whose name is an empty string
**** #'
A shortcut for ~function~ special form.
**** #:
Printed representation of an uninterned symbol, which precedes the symbol name.
**** #N
Printed representation of circular structures, where N is the number of the list.
#+begin_src emacs-lisp
  ;; Remember that setcdr returns the CDR, not the full list
  (let ((a (list 1)))
    (setcdr a a)) ; ⇒ (1 . #0)
  (eq a (cdr a)) ; ⇒ t
  (let ((a (list 1)))
    (setcdr a (copy-sequence a))) ; ⇒ (1)
#+end_src
**** #N= and #N#
See 'Read Syntax for Shared and Circular Objects'
**** #xN
N is a hexadecimal number (e.g., '#x2a').
**** #oN
N is an octal number.
**** #bN
N is a binary number.
**** #(...)
String text properties
**** #^
A char table.
**** #s(hash-table ...)
A hash table.
**** ?C
A character
*** Programming Types
Note that these types are not all reported as-is by ~type-of~, though many if not all have their own predicates.
**** Integer
There are two types of integers: fixnums and bignums.

Read syntax is an optional sign, followed by base-10 digits, followed by an optional period. The syntax for integers in bases other than 10 consists of '#' followed by a radix indicator and one or more digits:

#+begin_src emacs-lisp
  #b101100 ; ⇒ 44
  #o54 ; ⇒ 44
  #x2c ; ⇒ 44
  #24r1k ; ⇒ 44
#+end_src

The final example uses the generic 'r' radix that allows you to specify the base--in this example, 24. Allowed radix values are 2-36, and allowed digits are 0-9 and A-Z.
***** fixnums
Small integers. Minimum range is -536,870,912 to 536,870,911 (30 bits). Can be compared with ~eq~ (test for identical objects), unlike other numbers which must be tested with ~eql~ or ~=~ (see documentation for how the latter two differ).
***** bignums
Large integers, arbitrary precision. Operations that overflow a fixnum return a bignum.
**** Floating-Point
Read syntax requires a decimal point with at least one digit following, an exponent, or both (e.g., '1500.0' and '+15e2').
**** Character
Characters are simply intgers (as reported by ~type-of~) and are represented by their numeric character codes. Distinct from strings, or an array of characters. Characters in strings and buffers are limited to a range of 0 to 4194303 (22 bits). See ~(max-char)~. Codes 0 to 127 are ASCII. Characters that represent keyboard input have a wider range to account for modifier keys.
***** Basic Char Syntax
Printed representation is an integer. The read syntax begins with '?' followed by the character.

Escape punctuation characters with a special syntacic meaning in Lisp, such as ~?\(~ and ~?\\~. The table below (created using ~table-capture~ per https://www.emacswiki.org/emacs/TableMode) gives ASCII control characters or escape sequences:

+------------------------------+------------------------------+
|?\a ⇒ 7                       |control-g, C-g                |
+------------------------------+------------------------------+
|?\b ⇒ 8                       |backspace, BS, C-h            |
+------------------------------+------------------------------+
|?\t ⇒ 9                       |tab, TAB, C-i                 |
+------------------------------+------------------------------+
|?\n ⇒ 10                      |newline, C-j                  |
+------------------------------+------------------------------+
|?\v ⇒ 11                      |vertical tab, C-k             |
+------------------------------+------------------------------+
|?\f ⇒ 12                      |formfeed character, C-l       |
+------------------------------+------------------------------+
|?\r ⇒ 13                      |carriage return, RET, C-m     |
+------------------------------+------------------------------+
|?\e ⇒ 27                      |escape character, ESC, C-[    |
+------------------------------+------------------------------+
|?\s ⇒ 32                      |space character, SPC          |
+------------------------------+------------------------------+
|?\\ ⇒ 92                      |backslash character, \        |
+------------------------------+------------------------------+
|?\d ⇒ 127                     |delete character, DEL         |
+------------------------------+------------------------------+

Note that '?\s-' indicates a super modifier applied to a following character.

Backslashes are ignored when preceding non-control characters.

Backslashes must precede any of '()[]\;"', which are special characters in lisp. E.g., '?\\' is a single backslash charcter.

Backslashes before Unicode characters similar to the previous ASCII ones (e.g., Unicode quotes) help avoid confusion by readers of your code.
****** TODO Investigate this quote. What does it mean?
Backslashes before '|'`#.,' "avoid confusing the Emacs commands for editing Lisp code."
***** General Escape Syntax
These escape sequences can be used in strings, as well as single characters.
****** ?\N{NAME}
Spaces in Unicode names can be replaced by newlines to accommodate longer names.
****** ?\N{U+X} and ?\uxxxx and ?\Uxxxxxxxx
X/x is a hexadecimal Unicode code point. The latter two forms are fixed length hex strings (may have leading zeroes). Note that the Unicode standard defines code points only up to U+10ffff.
****** ?\x
This is followed by hexadecimal character codes (e.g., '?\x1'). Presumably this uses a file's encoding rather than Unicode code points, but I haven't tested it.
****** ?\octal
E.g. ?\101. Limited to octal range of 0 to 777.
***** Control-Character Syntax
Control can be represented by '\^' or '\C-'. E.g., '?\^i' and '?\C-I' are both the character whose value is 9. Note that the case of the letter does not matter.

In strings and buffers, only ASCII control characters are permitted (i.e., within the range 0-32). For keyboard input, any character can be a control character by prepending 'C-'. Control for non-ASCII characters in keyboard input is represented by the 2**26 bit. Text terminals can only generate the ASCII control characters, so an X windows server may be required to take full advantage of Emacs.

Emacs treats '?\^?' or '?\C-?' as DEL.

The caret syntax is preferred for strings, while the 'C-' syntax is preferred for keyboard input.
***** Meta-Character Syntax
Meta characters are represented by the 2**27 bit in a character.

In a string the 2**7 bit indicates a meta character; thus, these characters are limited to the range of 128 to 255 (extended ASCII).

The read syntax for meta characters is '\M-' (e.g. '?\M-A' or '?\M-\101). Can be combined with 'C-' (e.g., '?\M-\C-b' or '?\M-\002).
***** Other Character Modifier Bits
No way to represent shift in ASCII (uppercase letters have their own code point). X-based or graphical Emacs uses the 2**25 bit to indicate shift. Read syntax is '\S-' (e.g., '?\C-\S-o' or '?\C-\S-O are the same).

Three other modifier bits are hyper ('\H-'), super ('\s-'), and alt ('\A-'). Note that super without the dash is the space character, while uppercase S is shift. These have bits of 2*24, 2**23, and 2**22, respectively.
**** Symbol
A symbol is an object with a name. The name is the printed representation.

Symbols can serve as variables, functions, holders of property lists, or as a means of identification within a data structure. Each of these uses is independent of one another. E.g., you can have a function and a variable with the same name, and they will be distinguishable based on how they are used in a program.

Names can contain letters, digits, and '-+=*/_~!@$%^&:<>{}?'. Other characters can be escaped with a backslash. Unlike strings, there are no escape sequences (e.g., '\t' is 't' rather than a tab character.)

Note that '1+' and '\+1' are symbol names, while '+1' is the integer 1.
**** Sequence
A sequence is an ordered set of elements. The two types are lists and arrays.

Have a length /l/ and index 0 to /l-1/.

Sequences are always newly created on reading, so the same read syntax will not produce the same list. The exception is the emtpy list ~()~.
***** Cons Cell and List
A cons cell is an object that represents an ordered pair. Cons cell consists of two slots, the CAR and CDR. Can hold any object.

An object which is not a cons cell is known as an atom.

A list is a series of cons cells, linked together such that the CDR slot of each cons holds either next cons cell or the empty list.
****** Cons Read Syntax
Known as "dotted pair notation," this is a general syntax for cons cells that represents CAR and CDR explicitly: ~(a . b)~
****** List Read Syntax
Read syntax is one or more sets of (nested) balanced parentheses with elements inside. It is a shorthand for dotted pair notation:

~(1 2 3) ⇒ (1 . (2 . (3 . nil)))~
~(rose violet . buttercup ) ⇒ (rose . (violet . buttercup))~
****** Association List (alist)
A list whose elements are cons cells, called associations. Associations represent mappings between keys and values. Keys and values can be any Lisp objects. Associations can be simple cons cells

~((rose . red) (lily . white) (buttercup . yellow))~

#+begin_src emacs-lisp
  (setq alist-of-colors
        '((rose . red) (lily . white) (buttercup . yellow)))
  (car alist-of-colors) ; ⇒  (rose . red)
  (cdr alist-of-colors) ; ⇒ ((lily . white) (buttercup . yellow))
#+end_src

or lists

~((rose red) (lily white) (buttercup yellow))~.

If the association is a list, the value could be ~red~ (the CAR of the association's CDR). In this case, additional elements after ~red~ (the CAR of the CDR) could be used to store additional information. Alternatively, the value could be ~(red)~ (the association's CDR). Either convention may be used.
****** Property List (plist)
A property list or plist is a list of paired elements. The pair consists of a property name and property.

~(pine cones numbers (1 2 3) color "blue")~

In the example, the symbol ~pine~ is associated with the symbol ~cones~, ~numbers~ with ~(1 2 3)~, etc.

Unlike alists, plists ignore pair order but require unique property names to avoid naming conflicts.

An example of plists are those used for variables. Each variable's property list contains a property named ~variable-documentation~.
***** Array
Fixed-length. Accessing any elements takes the same amount of time, in contrast to lists which take time proportional to the position of the element. The four types of arrays are string, vector, char-table, and bool-vector.
****** String Type
An array of characters, with or without text properties.

Read syntax is double quotes surrounding text.

Double quotes and backslashes must be backslash-escaped within a string.

A backslash before a newline causes the newline to be discarded, and can be used to split long strings across multiple lines. Escaped spaces are also discarded.
******* Non-ASCII Characters in Strings
There are two text representations for non-ASCII characters in strings. Unibyte strings store raw bytes, and each character is a byte. These strings can contain only characters between 0 and 255 (extended ASCII). Multibyte strings store human-readable text with character values between 0 and 4194303.

Non-ASCII characters can be included in string constants literally. Whether the character and resulting string are treated as unibyte or multibyte depends on the source from which the string is read.

Non-ASCII characters can also be included as an escape sequence (see General Escape Syntax). Unicode-style escape sequences in a string constant force Emacs to treat it as multibyte. If there are no Unicode-style escape sequences, no hex or octal escape sequences outside the range of a unibyte string (i.e., 0 - 255), and no literal non-ASCII characters, Emacs assumes the string is unibyte (i.e., that all non-ASCII characters are within the extended ASCII range only).

In strings, hex and octal escape sequences should terminate each sequence with a backslash if followed by subsequent characters. Since escape sequences are variable length, Emacs interprets them greedily without a backslash. That is, if a character subsequent to the desired sequence forms a longer valid sequence, Emacs will interpret the subsequent character(s) as part of the sequence. Aside from terminating escape sequences, single backslashes are otherwise discarded.
******* Nonprinting Characters in Strings
Backslash escape sequences for ASCII nonprinting characters (e.g., '\t' and '\C-a') can also be used in strings as in characters.

Strings can only hold the the ASCII control characters. Strings do not distinguish case in ASCII control characters.

Strings can also only hold the extended ASCII meta characters (those with the 2**7 bit set). If strings are used in ~define-key~ or ~lookup-key~, this numeric code is translated to the equivalent meta character (i.e., with the 2**27 bit set).

Strings cannot hold characters with hyper, super, or alt modifiers. (Presumably, vectors must be used instead of strings when using e.g. ~define-key~.)
******* Text Properties in Strings
Special read and print syntax: ~#("/characters/" /property-data/...)~. /property-data/ consists of zero or more elements in groups of three: /beg/ /end/ /plist/. The former two are integers specifying a range of indices. /plist/ is the property list for that range. E.g., ~#("foo bar" 0 3 (face bold) 4 7 (face italic))~.
****** Vector Type
An array of elements of any type.

Unlike strings, characters in vectors cannot have text properties.

The printed representation and read syntax are both square brackets enclosing the vector elements: ~[1 "two" (three)]~.
****** Char-Table Type
Like vectors but indexed by any valid character code.

Printed representation is like a vector prepended with '#^'. A function ~make-char-table~ can be used to make them. Char tables can be used for case, character category, display, and syntax tables, which are detailed elsewhere in the manual.
****** Bool-Vector Type
An array of ~nil~ and/or ~t~.

Read syntax is '#&' followed by the length and then a (double-quoted) string. The string specifies the contents of the bool-vector. Each character in the string has a code point corresponding to each sequence of 8 elements in the bool-vector.

#+begin_src emacs-lisp
  (make-bool-vector 3 t)
       ⇒ #&3"^G"
  (make-bool-vector 3 nil)
       ⇒ #&3"^@"
#+end_src

in the first example, the string is '^G' or 111 in binary. In the second, '^@' or 0.

If the length is not a multiple of 8, the printed representation shows extra elements, but these extras really make no difference. For instance, in the next example, the two bool-vectors are equal, because only the first 3 bits are used:

(Note that \377 is 11111111 in binary, but the length specified is 3. Meanwhile, \007 is 111.)

#+BEGIN_SRC EMACS-LISP
(equal #&3"\377" #&3"\007")
     ⇒ t
#+END_SRC
**** Hash Table
Similar to an alist in that it maps keys to values but faster. The printed representation specifies its properties and contents:

#+BEGIN_SRC EMACS-LISP
  (make-hash-table)
       ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                               rehash-threshold 0.8125 data ())
#+END_SRC
**** Function
Non-compiled functions are anonymous lambda expressions. A named function in Lisp is just a symbol with a valid function in its function cell (another cell is a variable cell, which is why functions and variables can share names without confusion.). Functions can be called by name or at runtime via ~funcall~ and ~apply~.
***** Macro Type
Like a function with different argument-passing semantics.

Has the form of ~(macro ...)~, but is typically defined by the ~defmacro~ macro.
***** Primitive Function / Subr / Built-in Function Type
A Lisp-callable function written in C. Like normal functions, most evaluate all their arguments.

No read syntax. Prints in hash notation with the name of the subroutine:

#+BEGIN_SRC EMACS-LISP
  (symbol-function 'car)          ; Access the function cell
                                  ;   of the symbol.
       ⇒ #<subr car>
  (subrp (symbol-function 'car))  ; Is this a primitive function?
       ⇒ t                       ; Yes.
#+END_SRC

It is discouraged to redefine primitive functions, since Lisp code will reference the redefined function but C code will still call the built-in function.
****** Special Form
A primitive function that does not evaluate all of its arguments.
***** Byte-Code Function Type
Produced by byte-compiling Lisp code. ~type-of~ is ~compiled-function~. The evaluator handles this type specially when it appears in a function call.

The printed representation and read syntax is like that of a vector with an additional '#' before the left/opening square bracket.
**** Record
Like a vector whose first element holds the type returned by ~type-of~. Allows programmers to create new types not provided by Emacs.
***** Type Descriptor
A record which holds information about a type.
**** Autoload
A list whose first element is the symbol ~autoload~. Stored as the function definition of a symbol. After the real function is loaded, it replaces the autoload as the function definition of the symbol.

Usually created with the ~autoload~ function.
**** Finalizer
Used for garbage collection.
*** Editing Types
**** Buffer Type
Buffers hold text, may be displayed in a window(s), record position in /point/, and are associated with the following structures:

1. Local syntax table
2. Local keymap
3. List of buffer-local variable bindings
4. Overlays
5. Text properties for the text in the buffer

One buffer is the current buffer.

A buffer may be indirect, meaning it presents the text of another buffer.

Buffers have no read syntax and print '#<buffer BUFFER-NAME>'

#+begin_src emacs-lisp
  (current-buffer)
       ⇒ #<buffer objects.texi>
#+end_src
**** Marker Type
Denotes a position in a buffer, like point. Changes to a buffer automatically change the position of a marker to point between the same two characters.

Markers have no read syntax and print '#<marker at POSITION in BUFFER-NAME>'.
**** Window Type
Each window holds a buffer.

One window is the selected window.

Windows are grouped on-screen into frames. Each window belongs to only one frame.

Windows have no read syntax and print '#<window WINDOW-NUMBER on BUFFER-NAME>'
**** Frame Type
A frame is a screen area that contains one or more Emacs windows.

Frames have no read syntax and print '#<frame FRAME-TITLE ADDRESS>', where ADDRESS looks like e.g. '0xdac80' and can be used to uniquely identify a frame.
**** Terminal Type
A device capable of displaying frames.

Terminals have no read syntax and print '<terminal TERMINAL-NUMBER on TTY-NAME>', where TTY looks like e.g. '/dev/tty'.
**** Window Configuration Type
Stores information about positions, sizes, and contents of windows in a frame, so you can recreate the same arrangement of windows later.

No read syntax but prints '#<WINDOW-CONFIGURATION>'.
**** Frame Configuration Type
Like window configuration but for all frames instead of a single frame.
**** Process Type
A Lisp object that designates a subprocess created by the Emacs process. Takes input from and returns output to Emacs. Emacs can also send signals to them.
**** Thread Type                                                  :skip:
**** Mutex Type                                                   :skip:
**** Condition Variable Type                                      :skip:
**** Stream Type
A text source or sink. Markers, buffers, strings, and functions can be used as a stream. No read syntax or printed representation, and print as whatever primitive type they are.
**** Keymap Type
A list whose CAR is the symbol ~keymap~.
**** Overlay Type
Specifies properties for a range of a buffer. No read syntax and print in hash notation, giving the buffer name and range of positions.
**** Font Type
Three types. No read syntax.
***** Font Object
Prints '#<FONT-OBJECT>'
***** Font Spec
Prints '#<FONT-SPEC>'
***** Font Entity
Prints '$<FONT-ENTITY>'
*** Read Syntax for Shared and Circular Objects
Use '#n=' before an object to label it, and '#n#' to reference it. The reference is to the original object, not a copy, as shown in the example:
**** Shared Object
#+begin_src emacs-lisp
  (prog1 nil
    (setq x '(#1=(a) b #1#)))
  (eq (nth 0 x) (nth 2 x))
       ⇒ t

  (setq x '((a) b (a)))
  (eq (nth 0 x) (nth 2 x))
       ⇒ nil
#+end_src
**** Circular Object
This makes a list whose second element is the list itself:
#+begin_src emacs-lisp
  (prog1 nil
    (setq x '#1=(a #1#)))
  (eq x (cadr x))
       ⇒ t
#+end_src
*** Type Predicates
Emacs Lisp does not type-check arguments passed to functions, so functions must use predicates to test argument type. (Built-in functions do type check.)

See [[info:elisp#Type Predicates][Type Predicates]] for a list of type predicates.
**** typeof /object/
Returns a symbol naming the primitive type of /object/. Namely one of:
1. bool-vector
2. buffer
3. char-table
4. compiled-function (a.k.a. byte-code function)
5. condition-variable
6. cons
7. finalizer
8. float
9. font-entity
10. font-object
11. font-spec
12. frame
13. hash-table
14. integer
15. marker
16. mutex
17. overlay
18. process
19. string
20. subr
21. symbol
22. thread
23. vector
24. window
25. window-configuration.

If /object/ is a record the type specified by its first slot is returned.
*** Equality Predicates                                        :equality:
**** eq /object1/ /object2/
Returns ~t~ if arguments are the same object, and ~nil~ otherwise.

If objects are symbols with the same name, they are normally the same object. The make-symbol function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression. Distinct symbols with the same name are not eq:

#+begin_src emacs-lisp
  (eq (make-symbol "foo") 'foo)
       ⇒ nil
#+end_src

Other non-numeric types are equal only if they are the same object, meaning that a change in the contents of one will be reflected in the other.

Fixnums with the same value are equal. Different predicates should be used for non-fixnum numeric types, as they may or may not be the same object even if they have the same type and value. Strings should also not be compared with ~eq~.
**** equal /object1/ /object2/
Return ~t~ if arguments are the same data type and have equal components. For numbers, ~eql~ and ~equal~ are equivalent.

Cannot be used to compare buffers for equal contents, nor to compare circular lists (due to runaway recursion or unexpected results).

Comparison of strings is case-sensitive but does not compare text properties.
#+begin_src emacs-lisp
  (equal 'foo 'foo)
         ⇒ t

  (equal 1.0 1.0)
         ⇒ t

  (equal -0.0 0.0)
         ⇒ nil

  (equal 1 1.0)
         ⇒ nil

  (equal "asdf" "asdf")
       ⇒ t

  (eq "asdf" "asdf")
       ⇒ nil

  (equal '(1 (2 (3))) '(1 (2 (3))))
       ⇒ t

  (eq '(1 (2 (3))) '(1 (2 (3))))
       ⇒ nil

  (equal (point-marker) (point-marker))
       ⇒ t

  (eq (point-marker) (point-marker))
       ⇒ nil
#+end_src
**** equal-including-properties /object1/ /object2/
Like ~equal~ in all cases but also requires strings to have the same text properties to be equal.
*** Mutability
Some Lisp types can't mutate (e.g., numbers), some are always mutable (e.g., markers), and others are mixed (e.g., cons, vector, and string). For strings, ~"cons"~ and ~(symbol-name 'cons)~ should not be changed, but ~(copy-sequence "cons")~ and ~(make-string 3 ?a)~ can be changed via ~aset~.

A mutable object stops being mutable if it is **part of an expression that is evaluated**, such as ~x~ in the following example.

#+begin_src emacs-lisp
  (let* ((x (list 0.5))
         (y (eval (list 'quote x))))
    (setcar x 1.5) ;; The program should not do this.
    y)
#+end_src

Changing objects that should not be changed may or may not yield an error by the Lisp interpreter, a crash, or other unpredictable behavior.

The Lisp interpreter may create a single or multiple instances of a literal object, and there is no way to know in advance. E.g., the returned value of ~(eq "abc" "abc")~ is variable.

See also [[info:elisp#Quoting][elisp#Quoting]] and [[info:elisp#Backquote][elisp#Backquote]].
**** TODO read [[info:elisp#Evaluation][Evaluation]].
See the preceding example. It is unclear if there are other such scenarios aside from calling ~eval~ on a mutable object that change a mutable object to a nonmutable one within a Lisp program. Does a mutable object stay mutable otherwise throughout an entire program?

Some reading suggests that it's mainly self-evaluating forms (e.g., ~"abc"~ ) and quoted forms (e.g., ~'(1 2 3)~) that are immutable: https://en.wikipedia.org/wiki/Lisp_(programming_language)#Self-evaluating_forms_and_quoting.

The article, in fact, suggests that ~read~, ~print~, and ~eval~ themselves might be used to implement the Lisp REPL.
* Numbers                                                         :numeric:
** Integer Basics                                                    :int:
For functions that accept /number-or-marker/, when the argument is a marker, its position value is used and its buffer is ignored.

Text characters are represented by integers. Any integer between zero and the value of ~(max-char)~, inclusive, is considered to be valid as a character.

While older Emacs Lisp code could safely compare integers for numeric equality with eq, the presence of bignums means that equality predicates like ~eql~ and ~=~ should now be used to compare integers.

The range of values for a fixnum depends on the machine. The minimum range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 - 1), but many machines provide a wider range.

The range of values for bignums is limited by the amount of main memory, by machine characteristics such as the size of the word used to represent a bignum's exponent, and by the ~integer-width~ variable. These limits are typically much more generous than the limits for fixnums. A bignum is never numerically equal to a fixnum; Emacs always represents an integer in fixnum range as a fixnum, not a bignum.
#+begin_src emacs-lisp
  (bignump most-positive-fixnum) ; ⇒ nil
  (bignump (+ most-positive-fixnum 1)) ; ⇒ t
#+end_src
*** most-positive-fixnum
The greatest fixnum.
*** most-negative-fixnum
The least fixnum.
*** integer-width
Maximum number N of bits in safely-calculated bignums. Integers with absolute values less than 2**N do not signal a range error. A range error may or may not be guarantted above 2**N. Apparently this variable can be altered to increase range at the expense of additional computing power.
** Floating-Point Basics                                           :float:
The manual includes a link to [[https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html]["What Every Computer Scientist Should Know About Floating-Point Arithmetic"]] for further explanation of this data type and the IEEE-754 standard that applies to it.

NaN denotes, e.g., the results of ~(/ 0.0 0.0)~.

#+begin_src emacs-lisp
  (/ 0.0 0.0) ; ⇒ 0.0e+NaN
#+end_src

The two special floating point values are NaN and infinity.

NaN is never numerically equal to any value and can't be compared with ~=~; however, non-numeric functions treat NaNs as equal if their sign and significand agree (i.e., whether they are indistinguishable). In contrast, ~0.0~ and ~-0.0~ are numerically equal.

*NaN Read Syntax:*
'0.0e+NaN' and '-0.0e+NaN'

*Infinity Read Syntax*
'1.0e+INF' and '-1.0e+INF'
*** isnan /x/
Returns ~t~ if /x/ is a NaN, ~nil~ otherwise.
*** frexp /x/
Returns a cons cell ~(s . e)~ where /s/ and /e/ are respectively the significand and exponent of /x/. If x is finite, then x = ~(* s (expt 2 e))~. If /x/ is zero or infinity, then /s/ is the same as x. If /x/ is a NaN, then /s/ is also a NaN. If x is zero, then ~e~ is zero. Otherwise, ~e~ is between 0.5 (inclusive) and 1 (exclusive).
*** Idexp /s/ /e/
Given a numeric significand /s/ and an integer exponent /e/, this function returns the floating point number ~(* s (expt 2 e))~. Essentially the inverse operation of ~frexp~.
*** copysign /x1/ /x2/
Copies the sign of /x2/ to the value of /x1/ and returns the result.
*** logb /x/
Returns the binary exponent of /x/ (the logarithm base 2 of /x/ rounded down to an integer). If /x/ is zero or infinite, the value is infinity; if NaN, the value is a NaN. Note that the returned value will not necessarily match the exponent returned by ~frexp~.
** Type Predicates for Numbers                                      :pred:
*** bignump /object/
Returns ~t~ if /object/ is a large integer.
*** fixnump /object/
Returns ~t~ if /object/ is a small integer.
*** floatp /object/
Returns ~t~ if /object/ is floating point.
*** integerp /object/
Returns ~t~ if /object/ is an integer.
*** numberp /object/
Returns ~t~ if /object/ is floating point or integer.
*** natnump /object/
Returns ~t~ if /object/ is a positive integer (natural number), including 0.
*** wholenump /object/
A synonum for ~natnump~.
*** zerop /number/
Returns ~t~ if /number/ is zero.
** Comparison of Numbers                                         :compare:
To test numerical equality, use ~=~. All zeroes are equal (signed or otherwise), and floats may equal integers. NaN are never numerically equal but may be equal with non-numeric comparison.

In contrast, ~eql~ and ~equal~ only consider numbers equal if they are indistinguishable: same type, sign, and numeric value. So signed zeroes don't equal unsigned zeroes, integers and floats are unequal, and NaN may be considered equal if they share the same sign and significand.

If two fixnums are numerically equal, they are the same Lisp object. That is, ~eq~ is equivalent to ~=~ on fixnums. ~eq~ can be used when it is unknown whether the arguments are numbers, but it is better programming practice to use ~=~.

Because floating-point arithmetic is not exact, it is often a bad idea to check for equality of floating-point values. Usually it is better to test for approximate equality.
#+begin_src emacs-lisp
  (defvar fuzz-factor 1.0e-6)
  (defun approx-equal (x y)
    (or (= x y)
        (< (/ (abs (- x y))
              (max (abs x) (abs y)))
           fuzz-factor)))
#+end_src
**** = /number-or-marker/ &rest number-or-markers
Returns ~t~ if all arguments are numerically equal (NaN is never numerically equal). If a single argument is present, seems to return ~t~.
#+begin_src emacs-lisp
  (= 0.0 -0.0)
       ⇒ t

  (= 0.0e+NaN 0.0e+NaN)
       ⇒ nil
#+end_src
**** \slash{}= /number-or-marker1/ /number-or-marker2/
Note the literal leading slash. Unlike ~=~, requires exactly two arguments.
**** eql /object1/ /object2/
Returns ~t~ if arguments are ~eq~ or are indistinguishable numbers (type, sign, and value). For numbers, ~eql~ and ~equal~ are equivalent. Unlike ~eq~, ~eql~ can compare bignums as well as fixnums. Floats and integers will never be ~eql~ to each other, but NaN may.
#+begin_src emacs-lisp
  (eql 1.0 1.0)
         ⇒ t

  (eql -0.0 0.0)
         ⇒ nil

  (eql 1 1.0)
         ⇒ nil

  (eql 0.0e+NaN 0.0e+NaN)
       ⇒ t
#+end_src
**** < /number-or-marker/ &rest /number-or-markers/
Returns ~t~ if each argument is strictly less than the following argument.
**** <= /number-or-marker/ &rest /number-or-markers/
Returns ~t~ if each argument is less than or equal to the following argument.
**** > /number-or-marker/ &rest /number-or-markers/
Returns ~t~ if each argument is strictly greater than the following argument.
**** >= /number-or-marker/ &rest /number-or-markers/
Returns ~t~ if each argument is greater than or equal to the following argument.
**** max /number-or-marker/ &rest /numbers-or-markers/
Returns the largest of its arguments.
**** min /number-or-marker/ &rest /numbers-or-markers/
Returns the smallest of its arguments.
**** abs /number/
Returns the absolute value of /number/.
** Numeric Conversions                                     :round:convert:
~float~ converts an integer to float. The remaining functions convert floats to integers, possibly after dividing any number by /divisor/.
*** float /number/
*** truncate /number/ &optional /divisor/
Round towards zero. If /divisor/ is present, divide /number/ by /divisor/ before conversion to integer.
*** floor /number/ &optional /divisor/
Round towards negative infinity. If /divisor/ is present, divide /number/ by /divisor/ before conversion to integer, and division operation corresponds to ~mod~.
*** ceiling /number/ &optional /divisor/
Round towards positive infinity. If /divisor/ is present, divide /number/ by /divisor/ before conversion to integer.
*** round /number/ &optional /divisor/
Round towards the nearest integer (even integer for equidistant values). If /divisor/ is present, divide /number/ by /divisor/ before conversion to integer.
** Arithmetic Operations                                           :arith:
*** 1+ /number-or-marker/
*** 1- /number-or-marker/
*** + &rest /numbers-or-markers/
With a single argument, return it. With multiple arguments, add them. Return 0 if no arguments are given.
*** - &optional /number-or-marker/ &rest /numbers-or-markers/
With a single argument, return its negation. With multiple arguments, subtract them. Return 0 if no arguments are given.
*** * &rest /numbers-or-markers/
Return 1 if no arguments are given. With multiple arguments, multiply them.
*** / /number/ &rest /divisors/
With no /divisors/, return ~1 /// number~ (i.e., the multiplicative inverse). With one or more /divisors/, divide /number/ by /divisors/ and return the quotient.

If all the argumetns are integers, the result is an integer, obtained by rounding the quotient towards zero after *each* division. Thus, the multiplicative inverse of an integer aside from 1 and -1 is always zero.
*** % /dividend/ /divisor/
Returns the *integer remainder* after division. The arguments must be integers or markers. For any two integers,

#+begin_src emacs-lisp
  (+ (% dividend divisor)
     (* (/ dividend divisor) divisor))
#+end_src

always equal /dividend/ if /divisor/ is nonzero.

#+begin_src emacs-lisp
  (% 9 4)
     ⇒ 1

  (% -9 4)
     ⇒ -1

  (% 9 -4)
     ⇒ -1

  (% -9 -4)
     ⇒ 1
#+end_src
*** mod /dividend/ /divisor/
Returns the value of /dividend/ modulo /divisor/; that is, the remainder after "division" but with the same sign as /divisor/. Precisely, for any two numbers,
#+begin_src emacs-lisp
  (+ (mod dividend divisor)
     (* (floor dividend divisor) divisor))
#+end_src
always equals dividend, subject to rounding error if either argument is floating point (see below).

#+begin_src emacs-lisp
  (mod 9 4)
     ⇒ 1
  (floor 9 4)
     ⇒ 2

  (mod -9 4)
     ⇒ 3
  (floor -9 4)
     ⇒ 3

  (mod 9 -4)
     ⇒ -3
  (floor 9 -4)
     ⇒ -3

  (mod -9 -4)
     ⇒ -1
  (floor -9 -4)
     ⇒ 2
#+end_src

Unlike ~%~,  ~mod~ permits floating-point arguments. It rounds the quotient toward negative infinity to an integer, and uses it to compute the remainder.
#+begin_src emacs-lisp
  (mod 5.5 2.5)
       ⇒ .5
  (floor 5.5 2.5)
       ⇒ 2
#+end_src
** Rounding Operations                                       :float:round:
*** ffloor /float/
Rounds /float/ to the next lower integral value, and returns that value as a floating point.
*** fceiling /float/
Rounds /float/ to the next higher integral value, and returns that value as a floating point.
*** ftruncate /float/
Rounds /float/ towards zero to an integral value, and returns that value as a floating point.
*** fround /float/
Rounds /float/ to the nearest integral value, and returns that value as a floating point. Equidistant value is rounded to the even integral value.
#+begin_src emacs-lisp
  (fround 0.5)
          ⇒ 0.0
#+end_src
** Bitwise Operations                                           :bit:skip:
** Standard Mathematical Functions                              :exp:trig:
*** sin /arg/
/arg/ is measured in radians for ~sin~, ~cos~, and ~tan~.
*** cos /arg/
/arg/ is measured in radians for ~sin~, ~cos~, and ~tan~.
*** tan /arg/
/arg/ is measured in radians for ~sin~, ~cos~, and ~tan~.
*** asin /arg/
If /arg/ is outside [-1, 1], returns NaN.
Returned value is in radians.
*** acos /arg/
If /arg/ is outside of [-1, 1] returns NaN.
Returned value is in radians.
*** atan /y/ &optional /x/
Returned value is in radians.
*** exp /arg/
e to the power /arg/
*** log /arg/ &optional /base/
Logarithm  of /arg/, with base /base/. Without /base/, e is used as base. If /arg/ or /base/ are negative, ~log~ returns NaN.
*** expt /x/ /y/
/x/ raised to power /y/. If /x/ is finite and negative and /y/ is a finite non-integer, ~expt~ returns NaN.
*** sqrt /arg/
If /arg/ is finite and negative, ~sqrt~ returns NaN.
*** float-e
The mathematical constant e (2.71...)
*** float-pi
The mathematical constant pi (3.14...)
** Random Numbers                                            :skip:random:
* Strings and Characters                                              :str:
** [[info:elisp#String Basics][String and Character Basics]]
** Predicates for Strings                                           :pred:
*** stringp /object/
Returns ~t~ if /object/ is a string.
*** string-or-nullp /object/
Returns ~t~ if /object is a string or ~nil~.
*** char-or-string-p /object/                                      :char:
Returns ~t~ if object is a char or string.
** Creating Strings                                               :create:
*** make-string /count/ /character/ &optional /multibyte/
Returns a string made of /count/ repetitions of /character/. /mutlibyte/ can be used to override the default behavior of creating a unibyte string when /character/ is an ASCII character. This is useful if you need to concatenate the result with non-ASCII strings or replace some of its characters with non-ASCII characters.
#+begin_src emacs-lisp
  (make-string 5 ?x)
               ⇒ "xxxxx"
#+end_src
*** string &rest /characters/
Returns string composed of /characters/.
#+begin_src emacs-lisp
  (string ?a ?b ?c)
       ⇒ "abc"
#+end_src
*** substring /string/ &optional /start/ /end/
Returns a new string of characters from /string/ in the range of /start/ to /end/ (exclusive). A negative character counts from the end of the string, and ~nil~ stands for the length of the string (the last index is length-1). Omitting /start/ is equivalent to specifying 0 and /end/ to ~nil~.
#+begin_src emacs-lisp
  (substring "abcdefg" -3 nil)
             ⇒ "efg"

  ;; copy-sequence is preferred to this
  (substring "abcdefg")
             ⇒ "abcdefg"
#+end_src

Text properties of any copied characters are also copied.

Substring also accepts a vector.
#+begin_src emacs-lisp
  (substring [a b (c) "d"] 1 3)
       ⇒ [b (c)]
#+end_src

Reminder: Strings are zero-indexed but buffer text is one-indexed (see ~buffer-substring~).
*** substring-no-properties /string/ &optional /start/ /end/
Like ~substring~ but discards text properties.
*** concat &rest /sequences/
Returns a string consisting of the characters in its arguments (along with text properties). Arguments may be strings or lists or vectors of numbers. If no arguments, returns an empty string.

WARNING: Does not always allocate a new string, so mutating the returned value can inadvertently change another string. Use ~copy-sequence~ to safely return the result as a new string.

#+begin_src emacs-lisp
  (concat "abc" (list 120 121) [122])
       ⇒ "abcxyz"
#+end_src
*** split-string /string/ &optional /separators/ /omit-nulls/ /trim/
Splits /string/ into substrings based on regex /separators/. Each match for /separators/ defines a split point. Returns a list of substrings.

If /separators/ is ~nil~ or omitted, use the default value of ~split-string-default-separators~ and behave as if /omit-nulls/ is ~t~.

If /omit-nulls/ is ~nil~, the result includes null (empty) strings whenever there are two consecutive matches for /separators/ or a match is adjacent to the beginning or end of /string/.

#+begin_src emacs-lisp
  (split-string "  two words  ")
                ⇒ ("two" "words")

  ;; Note the [ ]+ in split-string-default-separators
  (split-string "  two words  " split-string-default-separators)
                ⇒ ("" "two" "words" "")

  ;; Using a single space when there are consecutive spaces at
  ;; the beginning and end
  (split-string "  two words  " " ")
                ⇒ ("" "" "two" "words" "" "")

  (split-string "  two words  " " " t)
                ⇒ ("two" "words")
#+end_src

Empty matches are counted except following a non-empty match at the end of a string or when /string/ is empty. The result is that a match is made between each character, splitting every character. If /omit-nulls/ is ~nil~, (1) empty matches at the start and end of the string result in null strings, as do matches within the string (because the empty match plus actual match count as two consecutive matches).

#+begin_src emacs-lisp
  ;; Null strings on non-empty matches
  (split-string "Soup is good food" "o")
       ⇒ ("S" "up is g" "" "d f" "" "d")

  ;; Note the empty match at beginning and end
  (split-string "Soup is good food" "o*")
       ⇒ ("" "S" "" "u" "p" " " "i" "s" " " "g" "" "d" " " "f" "" "d" "")

  ;; Non-empty match at end (same result as above)
  (split-string "Soup is good foodo" "o*")
       ⇒ ("" "S" "" "u" "p" " " "i" "s" " " "g" "" "d" " " "f" "" "d" "")

  ;; Value of /separators/ is irrelevant if /string/ is empty
  (split-string "" ".")
       ⇒ ("")

#+end_src

Somewhat odd, but predictable, behavior can occur for certain "non-greedy" values of separators that can prefer empty matches over non-empty matches. Again, such values rarely occur in practice:

#+begin_src emacs-lisp
  ;; All but the last character generate two matches (one empty and one-non empty)
  (split-string "ooo" "o*")
       ⇒ ("" "")
  (split-string "ooo" "o*" t)
       ⇒ nil

  ;; From the manual, and no idea how to interpret this
  (split-string "ooo" "\\|o+" t)
       ⇒ ("o" "o" "o")
#+end_src
*** split-string-default-separators
The default value of /separators/ for ~split-string~. It is difficult to see in the doc, but its value is "[ \f\t\n\r\v]+".
** Modifying Strings                                              :mutate:
*** store-substring /string/ /idx/ /obj/
Replaces characters starting at index /idx/ in /string/ with those in /obj/. Signals an error if this changes the length of the string or if any new character requires a different number of bytes from the previous character.
*** clear-string /string/
Makes /string/ a unibyte string, clears its contents to zeroes, and may change its length.

The suggested use case is clearing out strings that contain passwords.
** Comparison of Characters and Strings
*** char-equal /character1/ /character2/                           :char:
Returns ~t~ if the arguments represent the same character. Ignores differences in case if ~case-fold-search~ is non-~nil~.
*** string= /string1/ /string2/
Returns ~t~ if the characters of the arguments match exactly. Symbols are also allowed as arguments, in which case the symbol names are compared. Case is always significant, regardless of ~case-fold-search~.

Equivalent to ~equal~ for comparing two strings. Like ~equal~, it ignores string properties (see ~equal-including-properties~). Unlike ~equal~, it signals an error if either argument is not a string or symbol.

Ignoring technical complexities (see the manual for this function), unibyte and multibyte strings are considered ~equal~ when they contain the same ASCII characters.
*** string-equal /string1/ /string2/
An alias for ~string=~.
*** string-collate-equalp                                          :skip:
*** string<                                                        :skip:
*** string-lessp                                                   :skip:
*** string-greaterp                                                :skip:
*** string-collate-lessp                                           :skip:
*** string-version-lessp /string1/ /string2/
Compares string by lexicographical order but treat numeric characters as base-10 numbers.
#+begin_src emacs-lisp
  (string-version-lessp "apples2" "apples11")
                        ⇒ t
#+end_src
*** string-prefix-p                                                :skip:
*** string-suffix-p                                                :skip:
*** compare-strings                                                :skip:
*** string-distance                                                :skip:
*** assoc-string                                                   :skip:
** [[info:elisp#String Conversion][Conversion of Characters and Strings]]                          :convert:
*** number-to-string /number/
Returns /number/ as a string of its base-10 reperesentation.
#+begin_src emacs-lisp
  (number-to-string #x2c)
                    ⇒ "44"
#+end_src
*** string-to-char /string/                                        :char:
Returns the first character in /string/ or 0 if the string is empty. Except for this last condition, this is identical to ~(aref /string/ 0)~
*** string-to-number /string/ /string/ &optional /base/
Returns the numeric value of the characters in /string/. Floating point conversion only works in the default /base/ of 10. This function will read as much of the string as it can convert into a number. If no conversion is possible, 0 is returned.
#+begin_src emacs-lisp
  (string-to-number "1e5")
                    ⇒ 10000.0
  (string-to-number "abc1")
                    ⇒ 0
  (string-to-number "1abc")
                    ⇒ 1
#+end_src
** Formatting Strings                                             :format:
*** Format Specifications                                   :format_spec:
Format specifications start with '%'.

| Spec | Description                                              |
|------+----------------------------------------------------------|
| %s   | Replace spec with printed representation of object,      |
|      | without quoting                                          |
| %S   | Like %s with quoting ("" around strings and \ before     |
|      | special chars)                                           |
| %o   | Base-8 integer representation (octal)                    |
| %d   | Base-10 integer representation (accepts floats)          |
| %x   | Base-16 integer representation, lowercase                |
| %X   | Like %x but uppercase                                    |
| %e   | Exponential notation for a float                         |
| %f   | Decimal-point notation for a float                       |
| %g   | Exponential notation for float if exponent < -4 or >= 6. |
|      | Include a decimal point only if it is necessary.         |
| %%   | A literal '%'                                            |

If format functions have more format specs in /string/ than /objects/, an error is raised; if more /objects/ than specs, the extra /objects/ are ignored.
**** Field Numbers
A field number is a digit followed by a dollar sign, inserted between the percent and the subsequent character that usually make up a spec. Field numbers are one-indexed. This indicates the order of /objects/ to use:

#+begin_src emacs-lisp
  (format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
       ⇒ "y, z, %, x"
#+end_src
**** Flags and Width
A flag can be inserted directly after the percent sign (and after a field number, if present). E.g., '#' ensures a preceding '0' when used with spec '%o', or '0x'/'0X' for specs '%x' and '%X'. There are also flags for padding:

#+begin_src emacs-lisp
  (format "%06d is padded on the left with zeros" 123)
       ⇒ "000123 is padded on the left with zeros"

  (format "'%-6d' is padded on the right with spaces" 123)
       ⇒ "'123   ' is padded on the right"

  (format "The word '%-7s' actually has %d letters in it."
          "foo" (length "foo"))
       ⇒ "The word 'foo    ' actually has 3 letters in it."
#+end_src

Note also that the above examples have a width value between the padding flag and the letter portion of the spec. If explicit padding is omitted but is needed when the object is less than the width, padding typically consists of spaces on the left:

#+begin_src emacs-lisp
  (format "%5d is padded on the left with spaces" 123)
       ⇒ "  123 is padded on the left with spaces"
#+end_src

Conversely, if width is too small, the object is not truncated.
*** format /string/ &rest /objects/
Return /string/ after replacing any format specifications with the corresponding /objects/.

WARNING: Does not always allocate a new string.
*** format-message /string/ &rest /objects/
Like ~format~ but converts grave accents and apostrophes in /string/ per the value of ~text-quoting-style~.
** Custom Format Strings                                          :format:
*** format-spec /template /spec-alist/ &optional /only-present/
This function accepts a list of custom-made format specs (/spec-alist/). See the manual for usage.
** Case Conversion                                                  :case:
*** downcase /string-or-char/                                      :char:
*** upcase /string-or-char/                                        :char:
*** capitalize /string-or-char/                                    :char:
*** upcase-initials /string-or-char/                               :char:
** The Case Table                                                   :skip:
* Lists                                                         :list:cons:
Lists are the other type of sequence aside from arrays.

Proper lists are nil-terminated. Dotted lists are non-nil-terminated, and their printed representation uses dotted pair notation. Circular lists have a cons cell whose CDR points to a previous cons cell in the list.

Some list functions require proper lists, and most functions that try to find the end of a list enter infinite loops if given a circular list.

** My Notes on Shared Structure and Destructive Operations
*** Shared Structure in Cons Cells
Note that when two different variables refer to the same cons cell(s), changes to the CAR and CDR slots are reflected across both.
#+begin_src emacs-lisp
  (setq aa (cons (+ 1 1) (+ 2 2)))
  (setq bb aa)
  (setq old-car (car aa))
  (setq old-cdr (cdr aa))
  (setf (car aa)
        (+ (car aa) 10))
  bb ; (12 . 4)
  old-car ; 2
  old-cdr ; 4
#+end_src
*** Shared Structure in Lists
When we say lists share structure, we mean that they share some of the same cons cells. If you modify the CAR or CDR of these cons cells, the changes will be reflected across both.

#+begin_src emacs-lisp
  (setq a (list 1 2 "abc" "def"))
  (setq b (cons ?a (cons ?b (cddr a))))

  ;; 1 -> 2 ->
  ;;             3 -> 4
  ;; 97 -> 98 ->

  ;; a and b have a common tail starting at the third cons cell
  (eq (cddr a) (cddr b))
  ;; Change the CAR of the third cons cell (i.e., the third element)
  (setf (elt a 2) 5)
  ;; Change the CDR of the third cons cell
  (setf (cdddr b) nil)
#+end_src

With shared structure, the same element can be accessed from any list (though it may not have the same absolute position in each list if they have unshared structure) and modifications to the structure are visible in every list.

Some lists do not share outer structure--there are no common outer cons cells--but do share elements. That is, they are shallow copies of each other. Changing the CAR or CDR of an outer cons cell affects only a single list. Changes to a shared mutable element, however, affect every list sharing that element.

In this example, copy-sequence makes a mutable copy of the literal list ~'((1 2) (3 4))~.
#+begin_src emacs-lisp
  ;; Replace second element (i.e., CAR of second cons cell)
  (let* ((orig '((1 2) (3 4)))
         (copy (copy-sequence orig)))
    (setf (nth 1 copy) '(4 4))
    (list orig copy)) ; (((1 2) (3 4)) ((1 2) (4 4)))

  ;; Mutate second element
  (let* ((orig '((1 2) (3 4)))
         (copy (copy-sequence orig)))
    (setcdr (cadr copy) '(0))
    (list orig copy)) ; (((1 2) (3 0)) ((1 2) (3 0)))
#+end_src

~copy-tree~ can make deep copies of lists where even the innermost cons cells are no longer shared between the original and copied list.
#+begin_src emacs-lisp
  ;; Mutate second element in a deep copy
  (let* ((orig '((1 2) (3 4)))
         (copy (copy-tree orig)))
    (setcdr (cadr copy) '(0))
    (list orig copy)) ; (((1 2) (3 4)) ((1 2) (3 0)))
#+end_src

A word of warning that the elements of the innermost lists are still shared. E.g., mutating a string or array will not be isolated to the list used during the mutation.
#+begin_src emacs-lisp
  (setq x (list 1 (list 2) (string ?a ?b ?c)))
  (setq y (copy-tree x))
  (clear-string (nth 2 x))
  y ; (1 (2) "^@^@^@")
#+end_src

Here's a final exaple wrapping up the differences between shared structure, shallow copy, and deep copy.
#+begin_src emacs-lisp
  (setq x (list 1 (list 2 3) (list 4 (list 5))))
  (setq shared (cdr x))
  (setq shallow (copy-sequence x))
  (setq deep (copy-tree x))
  ; Replace an element
  (setf (nth 1 x) 10)
  ; Mutate an element
  (setf (car (nth 2 x)) 20)

  x ; (1 10 (20 (5)))
  shared ; (10 (20 (5)))
  shallow ; (1 (2 3) (20 (5)))
  deep ; (1 (2 3) (4 (5)))
#+end_src

Source: https://yoo2080.wordpress.com/2014/08/03/lisp-lists-and-destructive-functions/#sec-9. Note that this author illustrates copies by showing fixnums shared between two lists. But fixnums are always ~eq~, and whether lists are copies has no bearing on that. I think a better example would focus on when non-list mutable elements are shared. To the author's credit, he does attempt to delineate between (outer) list structure a la copy sequence and inner structure a la an example of alists.
*** Destructive Functions
Aside from returning objects that may share structure with function arguments, list functions may modify the argument list destructively. Thus, any variable that refers to the argument list will see the changes. Unexpected side effects may occur when mixing shared list structure with destructive functions:

#+begin_src emacs-lisp
  ;; All arg lists for append are copied except the last, so use of the
  ;; destructive function sort affects the final argument to append.
  (setq aa (list 5 3 1))
  (setq bb (list 4 2 0))
  (setq cc (append aa bb))
  (setq cc (sort cc '<))
  cc  ;  (0 1 2 3 4 5)
  aa  ;  (5 3 1)
  bb  ;  (4 5)
#+end_src

Note that the returned list is not necessarily the arg list with modification to some of its elements. It is apparently not always possible to know what happens to the arg list--in contrast to the returned list--so the term "destructive" can be quite literal.

Many functions come in pairs with one destructive version. E.g., ~append~ is nondestructive in contrast to ~nconc~. Similarly with ~butlast~ and ~nbutlast~. In general, it is safer to use the non-destructive version unless you need to optimize to use the more efficient destructive version. For functions without a non-destructive version (such as ~sort~ above), you can use ~copy-sequence~ prior to the destructive function call.

Source: https://yoo2080.wordpress.com/2014/08/03/lisp-lists-and-destructive-functions/#sec-9
** Predicates on Lists                                              :pred:
*** consp /object/
Returns ~t~ if /object/ is a (series of) cons cell(s). Note that ~nil~ is the only list that is not a (series of) cons cell(s) (see ~listp~).
*** atom /object/
Returns ~t~ if /object/ is not a cons cell (yes, a vector is atomic).
*** listp /object/
Returns ~t~ if /object/ is a (series of) cons cell(s) or ~nil~.
*** nlistp /object/
The negation of ~listp~.
*** null /object/
Returns ~t~ if /object/ is ~nil~. Technically identical to ~not~, but ~not~ is preferred when ~nil~ is used as a boolean (for its truth value) rather than as a list.
*** proper-list-p /object/
Returns the length of /object/ if it is a proper (nil-terminated) list, ~nil~ otherwise.
** Accessing List Elements
*** car /cons-cell/
Returns the value in the first slot (CAR) of /cons-cell/, or ~nil~ if /cons-cell/ is ~nil~.
*** cdr /cons-cell/
Returns the value in the second slot (CDR) of /cons-cell/, or ~nil~ if /cons-cell/ is ~nil~.
*** car-safe /object/
Returns the CAR of a cons cell while avoiding errors for other data types (returns ~nil~ in this case).
*** cdr-safe /object/
Returns the CDR of a cons cell while avoiding errors for other data types (returns ~nil~ in this case).
*** caar, cadr, cdar, and cddr
~cadr~ e.g. is defined as ~(car (cdr /cons-cell/))~. There are compositions of ~car~ and ~cdr~ up to c/xxxx/r (4-deep).
*** nth /n/ /list/
Returns the /n/-th element of list, numbered starting at index zero, or nil.

#+begin_example
  (nth n x) ≡ (car (nthcdr n x))
#+end_example
*** nthcdr /n/ /list/
Returns the /n/-th CDR of /list/. If /n/ is 0, return the entire list.
*** last /list/ &optional /n/
Return the /n/-th-to-last CDR. If /n/ is missing or 1, return the last CDR. If ~(> /n/ (length /list/))~, return the entire list.
*** butlast /x/ &optional /n/
Returns list /x/ with the last (/n/) elements removed. If /n/ > 0, returns a copy of the list. In general, ~(append (butlast /x/ /n/) (last /x/ /n/))~ returns a list equal to ~x~.
*** nbutlast /x/ &optional /n/
A destructive version of ~butlast~ that modifies the CDR directly rather than making a copy.
*** safe-length /list/
Return the length of /list/, with no risk of a type error or infinite loop for a circular list. Returns 0 if /list/ is not a cons cell, including ~nil~.
** Building Cons Cells and Lists                                  :create:
*** cons /object1/ /object2/
    Returns a cons cell. Often used to "add" elements to the front of a list, though it does not modify input lists. There is no equivalent way to add an element to the end of a list.
#+begin_src emacs-lisp
  ;; A cons cell
  (cons 1 2) ; (1 . 2)

  ;; A list
  (cons 1 '(2)) ; (1 2)

  ;; Shared structure
  (setq l '(2))
  (setq ll (cons 1 l))
  (eq (cdr ll) l) ; t
#+end_src
*** list &rest /objects/
Creates a list with /objects/ as its elements. If no /objects/ are given, returns ~nil~.
#+begin_src emacs-lisp
  (list 1 2 '(3 4 5)) ; (1 2 (3 4 5))
#+end_src
*** make-list /length/ /object/
Creates a list of /length/ elements, in which each element ~eq~ /object/.
#+begin_src emacs-lisp
  (setq l (make-list 3 '(a b))) ; ((a b) (a b) (a b))
  (eq (car l) (cadr l)) ; t
#+end_src
*** append &rest /sequences/
Returns a list containing all the elements of /sequences/, which may be lists, vectors, bool-vectors, or strings. *All but the last argument is copied.* The final argument becomes the CDR of the last cons cell created in the new list.
#+begin_src emacs-lisp
  (setq trees '(pine oak)) ; (pine oak)
  (setq more-trees (append '(maple birch) trees)) ; (maple birch pine oak)
  (eq trees (cddr more-trees)) ; t
#+end_src

If the final argument is not a list, the result is a dotted (non-nil-terminated) list. You can force a proper list by including ~nil~ as the last argument.
#+begin_src emacs-lisp
  (append [a b] "cd") ; (a b . "cd")
  (append [a b] "cd" nil) ; (a b 99 100)
#+end_src

With the help of ~apply~, you can append all the lists in a list of lists:
#+begin_src emacs-lisp
  (append '(a b c) '(x y z))
  ;; Equivalent to
  (apply 'append '((a b c) (x y z))) ; (a b c x y z)
#+end_src
*** copy-tree /tree/ &optional /vecp/
Returns a copy of /tree/ if it is a list. If not, /tree/ is simply returned. If /vecp/ is non-~nil~ and /tree/ is a vector, it will be copied instead of returned.

Note that this means the two trees do not share any outer or inner structure. See 'My Notes on Shared Structure and Destructive Operations'.
*** flatten-tree /tree/
Returns a flattened copy of /tree/ as a list.
*** number-sequence /from/ &optional /to/ /separation/
Returns a list of numbers from /from/ to /to/, incremented by /separation/. Floating point can produce unexpceted results. For instance, depending on the machine, ~(number-sequence 0.4 0.6 0.2)~ may return the one element list ~(0.4)~ rather than ~(0.4 0.6)~.
#+begin_src emacs-lisp
  (number-sequence 0.4 0.6 0.2)
#+end_src
The nth element of the list is computed by the exact formula ~(+ /from/ (* n /separation/))~. Thus, if one wants to make sure that /to/ is included in the list, one can pass an expression of this exact type for /to/. Alternatively, one can replace /to/ with a slightly larger value (or a slightly more negative value if separation is negative).
#+begin_src emacs-lisp
  (number-sequence 0.4 (+ 0.4 (* 1 0.2)) 0.2)
#+end_src
Note that n=1 above because lists are zero-indexed. Also, this method requires knowing the desired length, n, of your list.
** Modifying List Variables
These variables modify the variable (by creating a new list and saving it as the variable's value).
*** pop /listname/
Returns CAR from /listname/, then saves CDR into /listname/. When /listname/ is an unquoted symbol naming a list, this macro is equivalent to ~(prog1 (car listname) (setq listname (cdr listname)))~. The equivalency makes it apparent that structure is shared between the list in the previous version of the variable and the list in the new version of the variable. /listname/ can also be a generalized variable, in which case ~setf~ is used. If a generalized variable is used, the original list may be modified.
#+begin_src emacs-lisp
  ;; Original list is not modified...
  (setq x (list 1 2 3))
  (setq y x)
  (pop y)
  y ; (2 3)
  x ; (1 2 3)

  ;; ...but still shares CDR
  (eq y (cdr x)) ; t
  (setf (car y) 5)
  y ; (5 3)
  x ; (1 5 3)

  ;; Here, old list is modified.
  (setq a (list 0 1 2))
  (setq b a)
  (pop (cdr b)) ; (prog1 (car (cdr a)) (setf (cdr a) (cdr (cdr a))))
  a ; (0 2)
#+end_src
*** push /element/ /listname/
Creates a new list whose CAR is /element/ and whose CDR is /listname/. When /listname/ is an unquoted symbol naming a list, this macro is equivalent to ~(setq /listname/ (cons /element/ /listname/))~. If /listname/ is a generalized variable, ~setf~ is used instead of ~setq~.
#+begin_src emacs-lisp
  ;; Old list is not modified...
  (setq x (list 1 2 3))
  (setq y x)
  (push 0 x)
  x ; (0 1 2 3)
  y ; (1 2 3)

  ;; But still shares CDR with old list
  (eq y (cdr x)) ; t
  (setf (cadr x) 5)
  x ; (0 5 2 3)
  y ; (5 2 3)
#+end_src
*** add-to-list /symbol/ /element/ &optional /append/ /compare-fn/
Similar to ~push~ when /append/ is ~nil~ and /element/ is not an element of the list /symbol/. If /element/ is ~equal~ (by default) to an element in /symbol/, the original list is returned and /symbol/ is unchanged. If /compare-fn/ is ~nil~, ~equal~ is used for comparison of /element/ with other list elements. Note that /symbol/ is a quoted symbol, in contrast to the macro ~push~ or ~setq~.
#+begin_src emacs-lisp
  (setq foo '(a b))
  (add-to-list 'foo 'c) ; (c a b)
#+end_src

When no optional args are present, equivalen to ~(if (member value var) var (setq var (cons value var)))~.
*** add-to-ordered-list symbol element &optional order
Modifies the list contained in /symbol/ by inserting a new /element/ at position /order/ or adjusting an existing /element/'s position. Membership is tested with ~eq~. Elements of the list are sorted in non-decreasing numerical order and need not be consecutive. If multiple elements share the same /order/, their relative order is undefined. New elements without /order/ are added to the end of the ordered portion of the list, in no particular order. Non-numeric values of /order/ remove /order/ for an existing element. Note that /symbol/ is a quoted symbol, in contrast to the macro ~push~ or ~setq~.
#+begin_src emacs-lisp
  (setq foo '()) ;nil

  (add-to-ordered-list 'foo 'a 1)     ;; Add a
  ;; (a)

  (add-to-ordered-list 'foo 'c 3)     ;; Add c
  ;; (a c)

  (add-to-ordered-list 'foo 'b 2)     ;; Add b
  ;; (a b c)

  (add-to-ordered-list 'foo 'b 4)     ;; Move b
  ;; (a c b)

  (add-to-ordered-list 'foo 'd)       ;; Add d after ordered elements
  ;; (a c b d)

  (add-to-ordered-list 'foo 'e)       ;; Add e after ordered elements
  ;; (a c b e d)

  (add-to-ordered-list 'foo 'f)       ;; Add f after ordered elements
  ;; (a c b f e d)
#+end_src
*** delete-dups /list/
Destructively removes all ~equal~ duplicates from /list/, stores the result in /list/, and returns it. The first occurence of an element is always the one kept.
** Modifying Existing List Structure                              :mutate:
These are destructive operations that modify lists and should be applied only to mutable lists.
*** setcar /cons/ /object/
Replace the CAR of /cons/ with /object/ and return /object/.
#+begin_src emacs-lisp
  ;; Create two lists that are partly shared.
  (setq x1 (list 'a 'b 'c)) ; (a b c)
  (setq x2 (cons 'z (cdr x1))) ; (z b c)

  ;; Replace the CAR of a shared link.
  (setcar (cdr x1) 'foo) ; foo
  x1 ; (a foo c)
  x2 ; (z foo c)

  ;; Replace the CAR of a link that is not shared.
  (setcar x1 'baz) ; baz
  x1 ; (baz foo c)
  x2 ; (z foo c)
#+end_src
*** setcdr /cons/ /object/
Replace the CDR of /cons/ with /object/ and return /object/.
#+begin_src emacs-lisp
  ;; Remove an element
  (setq x1 (list 'a 'b 'c)) ; (a b c)
  (setcdr x1 (cdr (cdr x1))) ; (c)
  x1 ; (a c)

  ;; Insert an element
  (setq x1 (list 'a 'b 'c)) ; (a b c)
  (setcdr x1 (cons 'd (cdr x1))) ; (d b c)
  x1 ; (a d b c)
#+end_src
** Functions that Rearrange Lists (Destructive Append)            :mutate:
These are destructive operations.
*** nconc &rest /lists/
Returns a list containing all the elements of /lists/. Unlike ~append~, the /lists/ are not copied. Each of the /lists/ is modified so that its CDR points to the subsequent list. The final argument is not copied (or modified); thus, all but the last must be mutable lists, and the last need not be a list at all.
#+begin_src emacs-lisp
  (setq x (list 1))
  (setq y (list 2))
  (setq z (list 3))
  (nconc x y z)
  x ; (1 2 3)
  y ; (2 3)
  z ; (3)

  ;; CDR of x now points to y
  (eq (cdr x) y) ; t
#+end_src
** Using Lists as Sets                                               :set:
See ~cl-lib~ library for additional set operations from Common Lisp.

See also ~add-to-list~ and ~delete-dups~.
*** memq /object/ /list/
Tests to see whether /object/ ~eq~ a member of /list/; if so, it returns the part of /list/ that starts with the first occurence of /object/.
#+begin_src emacs-lisp
  (memq 'b '(a b c b a)) ; (b c b a)

  (memq '(2) '((1) (2)))    ; The two (2)s need not be eq.  might be nil or ((2)).
#+end_src
*** delq /object/ /list/
Destructively removes all elements ~eq~ to /object/ from /list/. In particular, it returns a sublist (~cdr~) if elements are at the front of the list, but changes the CDR (~setcdr~) for elements in the middle of the list. *Because you can't know whether the original variable has been changed unless you know which of these scenarios occurs, it is safest to assign the returned value to the variable which holds the original list.*
#+begin_src emacs-lisp
  (setq x (list 1 1 2 1 3 5 1))
  (delq 1 x) ; (2 3 5)

  ;; Nothing is deleted because (list 4) and '(4) are equal but not eq
  (setq y (list 'a 'b 'c '(4)))
  (delq (list 4) y) ; (a b c (4))
#+end_src
*** remq /object/ /list/
Returns a copy of /list/ with all elements removed which are ~eq~ to /object/.
#+begin_src emacs-lisp
  (setq sample-list (list 'a 'b 'c 'a 'b 'c))
  (remq 'a sample-list) ; (b c b c)
  sample-list ; (a b c a b c)
#+end_src
*** memql /object/ /list/
Like ~memq~ but compares by ~eql~.
*** member /object/ /list/
Like ~memq~ but compares by ~equal~.
*** delete /object/ /sequence/
If /sequence/ is a list, ~delete~ is like ~delq~ but compares with ~equal~. If /sequence/ is a vector or string, ~delete~ returns a copy of the sequence with all elements ~equal~ to /object/ removed.
#+begin_src emacs-lisp
  ;; If you want to change l reliably, write (setq l (delete '(2) l)).
  (setq l (list '(2) '(1) '(2)))
  (delete '(2) l) ; ((1))
  l ; ((2) (1))

  ;; In this case, it makes no difference whether you set l, though it is safest to do so
  (setq l (list '(2) '(1) '(2)))
  (delete '(1) l) ; ((2) (2))
  l ; ((2) (2))
#+end_src
*** remove /object/ /sequence/
Like ~remq~ but compares with ~equal~ and operates over any sequence. Alternatively, it is the non-destructive counterpart of ~delete~.
*** member-ignore-case /object/ /list/
Like ~member~ except that /object/ is a string and this function ignores differences in letter-case and text representation--unibyte strings are converted to multibyte prior to comparison.
** Association Lists                                               :alist:
*** assoc /key/ /alist/ &optional /testfn/
Returns the first association with CAR ~equal~ to /key/ in /alist/. ~equal~ can be replaced by /testfn/.
#+begin_src emacs-lisp
  ;; Symbolic keys, cons association
  (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
  (assoc 'oak trees) ; (oak . acorns)

  ;; Numeric keys, list association
  (setq needles-per-cluster
        '((2 "Austrian Pine" "Red Pine")
          (3 "Pitch Pine")
          (5 "White Pine")))

  (assoc 2 needles-per-cluster) ; (2 "Austrian Pine" "Red Pine")
#+end_src
*** rassoc /value/ /alist/
Returns the first association with CDR ~equal~ to /value/ in /alist/.
#+begin_src emacs-lisp
  (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
  (rassoc 'cones trees) ; (pine . cones)

  ;; List association
  (setq trees2 '((pine cones) (oak acorns) (maple seeds)))
  (rassoc '(cones) trees2) ; (pine cones)
#+end_src
*** assq /key/ /alist/
Like ~assoc~ but uses ~eq~ for comparison. Because ~eq~ is faster than ~equal~, this function is most commonly used when symbols are used as keys.
*** alist-get /key/ /alist/ &optional /default/ /remove/ /testfn/
Used to get, set, and remove values.

When getting values, like ~assq~ but returns /default/ instead of ~nil~ if there is no association with key matching /key/ (~eq~ or /testfn/).

It can be used with ~setf~ to modify the alist:
#+begin_src emacs-lisp
  (setq test-alist '((a . 0) (b . 1)))
  (setf (alist-get 'a test-alist) 9)
  (setf (alist-get 'c test-alist) 3)
  test-alist ; ((c . 3) (a . 9) (b . 1))
#+end_src

If /remove/ is non-~nil~ when setting a value, remove /key/'s association from /alist/ if the set value is ~eql~ to /default/.
#+begin_src emacs-lisp
  (setq test-alist '((a . 0) (b . 1)))
  (setf (alist-get 'b test-alist nil t) nil)
  test-alist ; ((a . 0))
#+end_src
*** rassq /value/ /alist/
Like ~rassoc~ but uses ~eq~ for comparison and cannot be used to retrieve list-style associations (proably due to its use of ~eq~).
#+begin_src emacs-lisp
  (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
  (rassq 'cones trees) ; (pine . cones)

  ;; List association
  (setq trees2 '((pine cones) (oak acorns) (maple seeds)))
  (rassq '(seeds) trees2) ; nil
#+end_src
*** assoc-default /key/ /alist/ &optional /test/ /default/         :skip:
*** copy-alist /alist/
Returns a two-level deep copy of /alist/. Thus, the associations may share values, but the associations themselves are different.
#+begin_src emacs-lisp
  (setq needles-per-cluster
        '((2 . ("Austrian Pine" "Red Pine"))
          (3 . ("Pitch Pine"))
          (5 . ("White Pine"))))
  (setq copy (copy-alist needles-per-cluster))

  ;; Associations differ
  (eq (car needles-per-cluster) (car copy)) ; nil

  ;; Associations' contents are eq
  (eq (cdr (car needles-per-cluster))
      (cdr (car copy))) ; t

  ;; But replacing contents in copy does not affect original
  (setcdr (assq 3 copy) '("Apple"))
#+end_src
*** assq-delete-all /key/ /alist/                                  :skip:
*** assoc-delete-all /key/ /alist/ &optional /test/                :skip:
*** rassq-delete-all /value/ /alist/                               :skip:
*** let-alist /alist/ /body/                                       :skip:
** Property Lists                                                  :plist:
*** plist-get /plist/ /property/
Returns the value of the property name ~eq~ to /property/ stored in /plist/
#+begin_src emacs-lisp
  (plist-get '(foo 4) 'foo)
#+end_src
*** plist-put /plist/ /property/ /value/
Store /value/ as the value of the property whose name ~eq~ /property/.

Sometimes but not always destructive. To be safe, reassign /plist/ to the returned plist.
*** lax-plist-get /plist/ /property/
Like ~plist-get~ with ~equal~
*** lax-plist-put /plist/ /property/ /value/
Like ~plist-put~ with ~equal~
*** plist-member /plist/ /property/
Unlike ~plist-get~, distinguishes between a missing property and a property with the value ~nil~. Does this by returning the tail of the plist whose CAR is /property/, or ~nil~.
#+begin_src emacs-lisp
  (setq my-plist (list 'bar 1 'foo nil 'blah 2))
  (plist-member my-plist 'foo) ; (foo nil blah 2)
  (plist-member my-plist 'nipples) ; nil
#+end_src
* Sequences
The preceding sections covered one type of sequence, lists, and one type of array--the other type of sequence--strings.
** Sequences
*** sequencep /object/
*** length /sequence/
Returns the number of elements in /sequence/. Signals ~wrong-type-argument~ if the argument is not a sequence or is a dotted list. Signals ~circular-list~ for circular lists. See ~safe-length~ for a function that works with all lists.
*** elt /sequence/ /index/
This function generalizes ~aref~ and ~nth~.

Returns the element of /sequence/ indexed by /index/, nil if out of bounds for lists (like ~nth~), or ~args-out-of-range~ if out of bounds for non-list sequences.
*** copy-sequence /seqr/
Returns a copy of /seqr/, which should be a sequence or record. The elements in /seqr/ and the return value are ~eq~. See 'My Notes on Shared Structure and Destructive Operations'.

This function does not work for dotted lists.

See also ~append~, ~concat~, and ~vconcat~.
*** reverse /sequence/
Creates a new sequence whose elements ~eq~ the elements of /sequence/, but in reverse order.
*** nreverse /sequence/
Destructive version of ~reverse~. For lists, it is best to assign the new list to the variable holding /sequence/, because the original list will be destroyed but not reversed. For vectors, you can skip assignment because the original vector will be reversed. Unlike ~reverse~, doesn't work with strings.
*** sort /sequence/ /predicate/
Only works for lists and vectors. Destructive for lists in that it changes CDRs to rearrange existing cons cells (the CAR in each cons cell does not change). Reassignment is advisable.

Sorts with /predicate/ stably; that is, elements with equal sort keys maintain their relative order before and after the sort. Stable sorting is important for successive sorts with different predicates.

/predicate/ function must accept two arguments. It is called with two elements of /sequence/. It should return non-~nil~ if the first element is "less" than the second and nil if "greater".
*** seq.el
These functions are provided by the ~seq~ library when it is loaded.
**** seq-elt /sequence/ /index/
**** seq-length /sequence/
**** seqp /object/
**** seq-drop /sequence/ /n/
**** seq-take /sequence/ /n/
**** seq-take-while /predicate/ /sequence/
**** seq-drop-while /predicate/ /sequence/
**** seq-do /function/ /sequence/
**** seq-map /function/ /sequence/
**** seq-map-indexed /function/ /sequence/
**** seq-mapn /function/ &rest /sequences/
**** seq-filter /predicate/ /sequence/
**** seq-remove /predicate/ /sequence/
**** seq-reduce /function/ /sequence/ /initial-value/
**** seq-some /predicate/ /sequence/
**** seq-find /predicate/ /sequence/ &optional /default/
**** seq-every-p /predicate/ /sequence/
**** seq-empty-p /sequence/
**** seq-count /predicate/ /sequence/
**** seq-sort /function/ /sequence/
**** seq-sort-by /function/ /predicate/ /sequence/
**** seq-contains-p /sequence/ /elt/ &optional /function/
**** seq-set-equal-p /sequence1/ /sequence2/ &optional /testfn/
**** seq-position /sequence/ /elt/ &optional /function/
**** seq-uniq /sequence/ &optional /function/
**** seq-subseq /sequence/ /start/ &optional /end/
**** seq-concatenate /type/ &rest /sequences/
**** seq-mapcat /function/ /sequence/ & optional /type/
**** seq-partition /sequence/ /n/
**** seq-intersection /sequence1/ /sequence2/ &optional /function/
**** seq-difference /sequence1/ /sequence2/ &optional /function/
**** seq-group-by /function/ /sequence/
**** seq-into /sequence/ /type/
* Arrays
* Vectors
